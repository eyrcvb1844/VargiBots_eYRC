#!/usr/bin/env python

from pickle import EMPTY_LIST
import rospy
import actionlib
import time
import datetime
import cv2
import math

from pkg_ros_iot_bridge.msg import msgMqttSub
from pkg_ros_iot_bridge.msg import msgRosIotAction
from pkg_ros_iot_bridge.msg import msgRosIotGoal
from pkg_ros_iot_bridge.msg import msgRosIotResult
from pyzbar.pyzbar import decode
from std_msgs.msg import String
from sensor_msgs.msg import Image
from importlib import import_module
from cv_bridge import CvBridge, CvBridgeError


class RosIotBridgeActionClient:
    '''
        This class takes the orders through the ros-iot bridge from the order node from 
        '/ros_iot_bridge/mqtt/sub'.
        It manages the inventory by processing the image it gets from the 2D camera through 
        rostopic "/eyrc/vb/camera_1/image_raw".
        It also sends orders to the ur5#1 arm on which box to dispatch through '/arm_commander'.
        If a certain order is not present in inventory, that case is also handled here.

        This receives the processing orders if a specific order is dispatched, shipped or is
        found in the inventory through rostopic '/order_status' and sends goals to the action server 
        to publish the information on their respective sheet on Google Sheets.

        
        :param _acIot: Action Client object.
        :param _goal_handles: Takes care of the goal.
        :param bridge: OpenCV object. Used for image processing.
        :param pub_empty: Publisher handle to publish to rostopic "/order_status".
        :param pub_arm: Publisher handle to publish to rostopic '/arm_commander'
        :param check: Boolean flag variable to control refreshing of inventory.
        :param boxes: Contains the colors of the boxes present in the shelf in order as present in the shelf.
    '''

    # Constructor
    def __init__(self):
        '''
            The constructor for RosIotBridgeActionClient.
            It initialises all the class variables.
            Subscribes and publishes to necessary topics, namely
            '/action_ros_iot'
            '/ros_iot_bridge/mqtt/sub'
            "/eyrc/vb/camera_1/image_raw"
            "/order_status"
            '/arm_commander'

        '''
        rospy.init_node('ur5_action_client')
        self._acIot = actionlib.ActionClient('/action_ros_iot',
                                             msgRosIotAction)
        self._goal_handles = {}
        self.bridge = CvBridge()
        self.boxes = []
        self.check = False
        rospy.Subscriber('/ros_iot_bridge/mqtt/sub',
                         msgMqttSub, self.mqttsub_callback)
        rospy.Subscriber("/eyrc/vb/camera_1/image_raw",
                         Image, self.cam_callback)
        rospy.Subscriber("/order_status", String, self.status_call)
        self.pub_empty = rospy.Publisher(
            "/order_status", String, queue_size=12)
        self.pub_arm = rospy.Publisher('/arm_commander', String, queue_size=12)
        self._acIot.wait_for_server()

    def on_transition(self, goal_handle):
        '''
            Starts when there is a change in Goal State.

            :param goal_handle: Goals that are added to be done.
        '''

        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.

        result = msgRosIotResult()

        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo(
            "Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))

        # Comm State - Monitors the State Machine of the Client which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done

        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())

            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if (result.flag_success == True):
                rospy.loginfo(
                    "Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo(
                    "Goal failed. Client Goal Handle #: " + str(index))

    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        '''
        This function is used to send Goals to Action Server

        :param arg_protocol: Protocol type by which the goal is done.
        :param arg_mode: Mode of operation to be carried out.
        :param arg_topic: Topic on which the goal is published.
        :param arg_message: Contains the message to be processed.

        :return: goal_handle
        '''
        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")

        # self.on_transition - It is a function pointer to a function which will be called when
        #                       there is a change of state in the Action Client State Machine
        goal_handle = self._acIot.send_goal(goal,
                                            self.on_transition,
                                            None)

        return goal_handle

    def status_call(self, feed):
        '''
        Processes the order status of the orders.

        This receives the status of orders from the rostopic 'order_status' and sends it
        to the Action Server as a goal. 
        Types of goals received: \n
        dispatched: An order of a specific order id has been dispatched.\n
        shipped: An order of a specific order id has been shipped.\n
        failed: An order of a specific order id has not been found in the inventory.

        :param feed: This contains the message in form '< order_id >;< goal >'
        :type feed: string

        '''
        feed = feed.data
        if('dispatched' in feed):
            order_id, status = feed.split(";")
            self.send_goal("http", "disp", "", order_id)
        elif('shipped' in feed):
            order_id, status = feed.split(";")
            self.send_goal("http", "ship", "", order_id)
        elif('failed' in feed):
            order_id, status = feed.split(";")
            self.send_goal("http", "fail", "", order_id)

    def mqttsub_callback(self, message):
        '''
        Processes orders sent in by the Action Server.

        This receives the orders, checks the inventory for the availability and publishes information to rostopic 
        '/arm_commander' in form "< color_of_box >;< x-coordinate on shelf >;< y-coordinate on shelf >;< order id >"
        if the order is available in the inventory, or else publishes "< order id >;failed" to rostopic "/order_status".

        It also manages the presence of boxes on the shelf as the orders are processed.

        :param message: Contains the order in form of a dictionary as a string, which contains all relevant information regarding the order.
        :type message: string
        '''
        order = eval(message.message)
        string = ""
        order_code = {"Medicine": "red", "Food": "yellow", "Clothes": "green"}
        val = order_code[order["item"]]
        if(val in self.boxes):
            ind = self.boxes.index(val)
            string = val+";"+str(ind/3)+";"+str(ind % 3) + \
                ";"+str(order["order_id"])
            self.boxes[ind] = 'NA'
            print(string)
            self.pub_arm.publish(string)
        else:
            self.pub_empty.publish(str(order["order_id"])+";"+'failed')
            print("\n\n\nINVENTORY EMPTY \n\n\n")

    def get_qr_data(self, arg_image):
        '''
        Decodes of the QR code present in the image.

        Receives the image and decodes the QR present in it.
        Uses decode function from pyzbar to decode the QR code.

        :param arg_image: A 2D Image array in which the QR code is decoded.
        :type arg_image: Image

        :return: Returns the decoded data if QR code can be decoded or is present at all. Returns 'NA' otherwise.
        :type: string
        '''
        qr_result = decode(arg_image)

        if (len(qr_result) > 0):
            return (qr_result[0].data)
        else:
            return ('NA')

    def cam_callback(self, data):
        '''
        Callback function that receives the image taken by 2D camera.
        It also is responsible for the decoding of QR code and making of the inventory.

        :param data: A message conveying the image.
        :type data: sensor_msgs::Image
        '''

        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            rospy.logerr(e)


        image = cv_image

        resized_image = cv2.resize(image, (720, 1280))
        cropped = resized_image[310:-380, 110:-110, :].copy()
        if self.check:
            self.qr_codes(cropped)
            self.check = False
            self.inventory()
        cv2.waitKey(3)

    def qr_codes(self, image):
        '''
        Takes an image, slices it to get the QR code of the boxes.
        Tuned to get accurate results for the current setup.

        :param image: Message containing an image of the shelf with or without the boxes.
        :type image: sensor_msgs::Image message
        '''
        i = 0
        s = 0
        temp = list()
        while(i < 590 and s < 12):
            c = 0
            j = 0
            while(j < 500):
                box = image[i:i+int(590/4), j:j+int(500/3), :].copy()
                if c != 3:
                    temp.append(self.get_qr_data(box))
                    s += 1
                j += int(500/3)
                c += 1
            i += int(590/4)
        self.boxes = temp

    def inventory(self):
        '''
        Creates the inventory and logs the inventory data as a Goal.

        It creates the inventory from the decoded QR codes, uses relevant information to create the SKU, adds necessary 
        information that needs to be logged on the Google Sheet 'Inventory' and sends it as a goal to the Action Server.
        '''
        string = ""
        cn = 0
        x = datetime.datetime.now()
        m = x.strftime("%m")
        y = x.strftime("%y")
        encode = {"red": ["R", "Medicine", "HP", "450"], "yellow": [
            "Y", "Food", "MP", "250"], "green": ["G", "Clothes", "LP", "150"]}
        for i in self.boxes:
            r = int(cn/3)
            c = cn % 3
            inv_dict = {"id": "Inventory", "Team Id": "VB#1844", "Unique Id": "axaKcGsN", "SKU": "{}{}{}{}{}".format(encode[i][0], r, c, m, y), "Item": encode[i][1],	"Priority": encode[i][2], "Storage Number": "R{} C{}".format(r, c),
                        "Cost": encode[i][3], "Quantity": "1"}
            string = str(inv_dict)+";"+string
            cn += 1
        string = string[:-1]
        self.send_goal("http", "inv", "", string)


def main():
    '''
    Creates RosIotBridgeActionClient instance and keeps the node running.
    Also, turns on the flag 'check' when image from 2D camera needs to be processed.
    '''
    manager = RosIotBridgeActionClient()
    rospy.sleep(5.5)
    manager.check = True
    rospy.spin()


if __name__ == '__main__':
    main()
